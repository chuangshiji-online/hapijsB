/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['monitor.js']) {
  _$jscoverage['monitor.js'] = [];
  _$jscoverage['monitor.js'][4] = 0;
  _$jscoverage['monitor.js'][5] = 0;
  _$jscoverage['monitor.js'][6] = 0;
  _$jscoverage['monitor.js'][7] = 0;
  _$jscoverage['monitor.js'][14] = 0;
  _$jscoverage['monitor.js'][16] = 0;
  _$jscoverage['monitor.js'][19] = 0;
  _$jscoverage['monitor.js'][20] = 0;
  _$jscoverage['monitor.js'][23] = 0;
  _$jscoverage['monitor.js'][25] = 0;
  _$jscoverage['monitor.js'][30] = 0;
  _$jscoverage['monitor.js'][36] = 0;
  _$jscoverage['monitor.js'][51] = 0;
  _$jscoverage['monitor.js'][54] = 0;
  _$jscoverage['monitor.js'][60] = 0;
  _$jscoverage['monitor.js'][67] = 0;
  _$jscoverage['monitor.js'][68] = 0;
  _$jscoverage['monitor.js'][69] = 0;
  _$jscoverage['monitor.js'][72] = 0;
  _$jscoverage['monitor.js'][73] = 0;
  _$jscoverage['monitor.js'][74] = 0;
  _$jscoverage['monitor.js'][75] = 0;
  _$jscoverage['monitor.js'][77] = 0;
  _$jscoverage['monitor.js'][80] = 0;
  _$jscoverage['monitor.js'][84] = 0;
  _$jscoverage['monitor.js'][90] = 0;
  _$jscoverage['monitor.js'][91] = 0;
  _$jscoverage['monitor.js'][94] = 0;
  _$jscoverage['monitor.js'][100] = 0;
  _$jscoverage['monitor.js'][101] = 0;
  _$jscoverage['monitor.js'][102] = 0;
  _$jscoverage['monitor.js'][105] = 0;
  _$jscoverage['monitor.js'][106] = 0;
  _$jscoverage['monitor.js'][109] = 0;
  _$jscoverage['monitor.js'][112] = 0;
  _$jscoverage['monitor.js'][118] = 0;
  _$jscoverage['monitor.js'][122] = 0;
  _$jscoverage['monitor.js'][123] = 0;
  _$jscoverage['monitor.js'][125] = 0;
  _$jscoverage['monitor.js'][126] = 0;
  _$jscoverage['monitor.js'][128] = 0;
  _$jscoverage['monitor.js'][133] = 0;
  _$jscoverage['monitor.js'][138] = 0;
  _$jscoverage['monitor.js'][141] = 0;
  _$jscoverage['monitor.js'][142] = 0;
  _$jscoverage['monitor.js'][143] = 0;
  _$jscoverage['monitor.js'][144] = 0;
  _$jscoverage['monitor.js'][145] = 0;
  _$jscoverage['monitor.js'][147] = 0;
  _$jscoverage['monitor.js'][148] = 0;
  _$jscoverage['monitor.js'][149] = 0;
  _$jscoverage['monitor.js'][150] = 0;
  _$jscoverage['monitor.js'][154] = 0;
  _$jscoverage['monitor.js'][157] = 0;
  _$jscoverage['monitor.js'][158] = 0;
  _$jscoverage['monitor.js'][159] = 0;
  _$jscoverage['monitor.js'][161] = 0;
  _$jscoverage['monitor.js'][170] = 0;
  _$jscoverage['monitor.js'][171] = 0;
  _$jscoverage['monitor.js'][172] = 0;
  _$jscoverage['monitor.js'][178] = 0;
  _$jscoverage['monitor.js'][179] = 0;
  _$jscoverage['monitor.js'][180] = 0;
  _$jscoverage['monitor.js'][186] = 0;
  _$jscoverage['monitor.js'][195] = 0;
  _$jscoverage['monitor.js'][197] = 0;
  _$jscoverage['monitor.js'][199] = 0;
  _$jscoverage['monitor.js'][208] = 0;
  _$jscoverage['monitor.js'][209] = 0;
  _$jscoverage['monitor.js'][210] = 0;
  _$jscoverage['monitor.js'][211] = 0;
  _$jscoverage['monitor.js'][212] = 0;
  _$jscoverage['monitor.js'][222] = 0;
  _$jscoverage['monitor.js'][223] = 0;
  _$jscoverage['monitor.js'][224] = 0;
  _$jscoverage['monitor.js'][225] = 0;
  _$jscoverage['monitor.js'][226] = 0;
  _$jscoverage['monitor.js'][229] = 0;
  _$jscoverage['monitor.js'][230] = 0;
  _$jscoverage['monitor.js'][232] = 0;
  _$jscoverage['monitor.js'][233] = 0;
  _$jscoverage['monitor.js'][234] = 0;
  _$jscoverage['monitor.js'][235] = 0;
  _$jscoverage['monitor.js'][236] = 0;
  _$jscoverage['monitor.js'][237] = 0;
  _$jscoverage['monitor.js'][238] = 0;
  _$jscoverage['monitor.js'][239] = 0;
  _$jscoverage['monitor.js'][241] = 0;
  _$jscoverage['monitor.js'][242] = 0;
  _$jscoverage['monitor.js'][246] = 0;
  _$jscoverage['monitor.js'][247] = 0;
  _$jscoverage['monitor.js'][250] = 0;
  _$jscoverage['monitor.js'][251] = 0;
  _$jscoverage['monitor.js'][253] = 0;
  _$jscoverage['monitor.js'][256] = 0;
  _$jscoverage['monitor.js'][259] = 0;
  _$jscoverage['monitor.js'][269] = 0;
  _$jscoverage['monitor.js'][271] = 0;
  _$jscoverage['monitor.js'][272] = 0;
  _$jscoverage['monitor.js'][273] = 0;
  _$jscoverage['monitor.js'][276] = 0;
  _$jscoverage['monitor.js'][277] = 0;
  _$jscoverage['monitor.js'][278] = 0;
  _$jscoverage['monitor.js'][279] = 0;
  _$jscoverage['monitor.js'][280] = 0;
  _$jscoverage['monitor.js'][281] = 0;
  _$jscoverage['monitor.js'][282] = 0;
  _$jscoverage['monitor.js'][284] = 0;
  _$jscoverage['monitor.js'][321] = 0;
}
_$jscoverage['monitor.js'][4]++;
var child_process = require("child_process");
_$jscoverage['monitor.js'][5]++;
var exec = child_process.exec;
_$jscoverage['monitor.js'][6]++;
var fs = require("fs");
_$jscoverage['monitor.js'][7]++;
var Utils = require("./utils");
_$jscoverage['monitor.js'][14]++;
function Monitor(options) {
  _$jscoverage['monitor.js'][16]++;
  this.options = Utils.merge({}, this._options, options || {});
  _$jscoverage['monitor.js'][19]++;
  if (process.platform !== "linux") {
    _$jscoverage['monitor.js'][20]++;
    throw process.platform + " is currently not supported by Monitor";
  }
  _$jscoverage['monitor.js'][23]++;
  this.MaxRAM = this.getMaxRAM();
  _$jscoverage['monitor.js'][25]++;
  this.public_methods = ["uptime", "memory", "cpu", "pcpu", "response_time"];
  _$jscoverage['monitor.js'][30]++;
  return this;
}
_$jscoverage['monitor.js'][36]++;
Monitor.prototype._options = {outbound: {transport: "http", host: null, interval: 30000}, inbound: {route: "/_monitor/"}, geodat: null};
_$jscoverage['monitor.js'][51]++;
Monitor.prototype.register = (function () {
  _$jscoverage['monitor.js'][54]++;
  process.on("exit", this.deregister);
});
_$jscoverage['monitor.js'][60]++;
Monitor.prototype.deregister = (function () {
});
_$jscoverage['monitor.js'][67]++;
Monitor.prototype.get_geocity = (function () {
  _$jscoverage['monitor.js'][68]++;
  if (typeof this.options.geodat !== "undefined" && this.options.geodata !== null) {
    _$jscoverage['monitor.js'][69]++;
    if (path.existsSync(this.options.geodat)) {
      _$jscoverage['monitor.js'][72]++;
      try {
        _$jscoverage['monitor.js'][73]++;
        var geoip = require("geoip");
        _$jscoverage['monitor.js'][74]++;
        var City = geoip.City;
        _$jscoverage['monitor.js'][75]++;
        var city = new City(this.options.geodat);
      }
      catch (err) {
        _$jscoverage['monitor.js'][77]++;
        return null;
      }
      _$jscoverage['monitor.js'][80]++;
      return this.options.geodat;
    }
  }
  _$jscoverage['monitor.js'][84]++;
  return null;
});
_$jscoverage['monitor.js'][90]++;
Monitor.prototype.onPreRoute = (function (req, res, next) {
  _$jscoverage['monitor.js'][91]++;
  req._startTime = new Date();
  _$jscoverage['monitor.js'][94]++;
  next();
});
_$jscoverage['monitor.js'][100]++;
Monitor.prototype.onPreHandler = (function () {
  _$jscoverage['monitor.js'][101]++;
  var wrapped = (function (req, res, next) {
  _$jscoverage['monitor.js'][102]++;
  if (! req._startTime) {
    _$jscoverage['monitor.js'][102]++;
    throw "Monitor.onPreHandler middleware requires Monitor.onPreRoute";
  }
  _$jscoverage['monitor.js'][105]++;
  for (var i in this.public_methods) {
    _$jscoverage['monitor.js'][106]++;
    req[this.public_methods[i]] = this[this.public_methods[i]];
}
  _$jscoverage['monitor.js'][109]++;
  next();
});
  _$jscoverage['monitor.js'][112]++;
  return wrapped;
});
_$jscoverage['monitor.js'][118]++;
Monitor.prototype.onPostHandler = (function () {
  _$jscoverage['monitor.js'][122]++;
  var wrapped = (function (req, res, next) {
  _$jscoverage['monitor.js'][123]++;
  if (! req._startTime) {
    _$jscoverage['monitor.js'][123]++;
    throw "Monitor.onPostHandler middleware requires Monitor.onPreRoute";
  }
  _$jscoverage['monitor.js'][125]++;
  try {
    _$jscoverage['monitor.js'][126]++;
    var url = decodeURIComponent(req.url);
  }
  catch (e) {
    _$jscoverage['monitor.js'][128]++;
    throw e;
  }
  _$jscoverage['monitor.js'][133]++;
  next();
});
  _$jscoverage['monitor.js'][138]++;
  return wrapped;
});
_$jscoverage['monitor.js'][141]++;
Monitor.prototype.calcMaxRAM = (function () {
  _$jscoverage['monitor.js'][142]++;
  var meminfo = "/proc/meminfo";
  _$jscoverage['monitor.js'][143]++;
  var pattern = /MemTotal:[\s]+(\d+)\s+kB/;
  _$jscoverage['monitor.js'][144]++;
  var meminfoContents = fs.readFileSync(meminfo);
  _$jscoverage['monitor.js'][145]++;
  var match = pattern.exec(meminfoContents.toString());
  _$jscoverage['monitor.js'][147]++;
  if (match !== null) {
    _$jscoverage['monitor.js'][148]++;
    var totalRAM = parseInt(match[1]) * 1000;
    _$jscoverage['monitor.js'][149]++;
    if (! isNaN(totalRAM)) {
      _$jscoverage['monitor.js'][150]++;
      return totalRAM;
    }
  }
  _$jscoverage['monitor.js'][154]++;
  throw "Unable to determined Maximum Available RAM";
});
_$jscoverage['monitor.js'][157]++;
Monitor.prototype.getMaxRAM = (function () {
  _$jscoverage['monitor.js'][158]++;
  if (typeof this.MaxRAM === "undefined" || this.MaxRAM === null) {
    _$jscoverage['monitor.js'][159]++;
    this.MaxRAM = this.calcMaxRAM();
  }
  _$jscoverage['monitor.js'][161]++;
  return this.MaxRAM;
});
_$jscoverage['monitor.js'][170]++;
Monitor.prototype.uptime = (function (digits) {
  _$jscoverage['monitor.js'][171]++;
  digits = digits || 2;
  _$jscoverage['monitor.js'][172]++;
  return process.uptime().toFixed(digits);
});
_$jscoverage['monitor.js'][178]++;
Monitor.prototype.memory = (function () {
  _$jscoverage['monitor.js'][179]++;
  var snapshot = process.memoryUsage();
  _$jscoverage['monitor.js'][180]++;
  var usage = {total: this.getMaxRAM(), used: snapshot.rss + snapshot.heapTotal};
  _$jscoverage['monitor.js'][186]++;
  return usage;
});
_$jscoverage['monitor.js'][195]++;
Monitor.prototype.responseTime = Monitor.prototype.response_time = (function (req) {
  _$jscoverage['monitor.js'][197]++;
  if (! req._startTime) {
    _$jscoverage['monitor.js'][197]++;
    return null;
  }
  _$jscoverage['monitor.js'][199]++;
  return new Date() - req._startTime;
});
_$jscoverage['monitor.js'][208]++;
Monitor.prototype.pcpu = (function (callback) {
  _$jscoverage['monitor.js'][209]++;
  exec("ps -eo pcpu,pid | grep " + process.pid, (function (error, stdout, stderr) {
  _$jscoverage['monitor.js'][210]++;
  if (error) {
    _$jscoverage['monitor.js'][210]++;
    return callback(error);
  }
  _$jscoverage['monitor.js'][211]++;
  var cpuUsage = Number(stdout.split(" ").shift()).toFixed(2);
  _$jscoverage['monitor.js'][212]++;
  callback(null, cpuUsage);
}));
});
_$jscoverage['monitor.js'][222]++;
Monitor.prototype.poll_cpu = (function (target, callback) {
  _$jscoverage['monitor.js'][223]++;
  var statfile = "/proc/stat";
  _$jscoverage['monitor.js'][224]++;
  try {
    _$jscoverage['monitor.js'][225]++;
    fs.readFile(statfile, (function (err, contents) {
  _$jscoverage['monitor.js'][226]++;
  if (err) {
    _$jscoverage['monitor.js'][226]++;
    throw err;
  }
  _$jscoverage['monitor.js'][229]++;
  var pattern = /cpu[\d]?[\s]+(.*)/g;
  _$jscoverage['monitor.js'][230]++;
  var file_contents = contents.toString();
  _$jscoverage['monitor.js'][232]++;
  var result;
  _$jscoverage['monitor.js'][233]++;
  var cpulines = {};
  _$jscoverage['monitor.js'][234]++;
  while ((result = pattern.exec(file_contents)) != null) {
    _$jscoverage['monitor.js'][235]++;
    var source = result[0].split(/\s+/);
    _$jscoverage['monitor.js'][236]++;
    var cpu = source.shift();
    _$jscoverage['monitor.js'][237]++;
    var line = source.map((function (d) {
  _$jscoverage['monitor.js'][237]++;
  return + d;
}));
    _$jscoverage['monitor.js'][238]++;
    line = line.slice(0, 4);
    _$jscoverage['monitor.js'][239]++;
    cpulines[cpu] = line;
    _$jscoverage['monitor.js'][241]++;
    if (target === cpu) {
      _$jscoverage['monitor.js'][242]++;
      break;
    }
}
  _$jscoverage['monitor.js'][246]++;
  if (! cpulines.hasOwnProperty(target)) {
    _$jscoverage['monitor.js'][247]++;
    return callback("No such target found for Monitor.poll_cpu (" + target + " does not exist)");
  }
  _$jscoverage['monitor.js'][250]++;
  var cpuline = cpulines[target];
  _$jscoverage['monitor.js'][251]++;
  var cpustats = {idle: cpuline[3], total: cpuline.reduce((function (a, b) {
  _$jscoverage['monitor.js'][253]++;
  return a + b;
}))};
  _$jscoverage['monitor.js'][256]++;
  return callback(null, cpustats);
}));
  }
  catch (err) {
    _$jscoverage['monitor.js'][259]++;
    return callback(err);
  }
});
_$jscoverage['monitor.js'][269]++;
Monitor.prototype.cpu = (function (target, callback) {
  _$jscoverage['monitor.js'][271]++;
  if (typeof target === "function") {
    _$jscoverage['monitor.js'][272]++;
    callback = target;
    _$jscoverage['monitor.js'][273]++;
    target = "cpu";
  }
  _$jscoverage['monitor.js'][276]++;
  var self = this;
  _$jscoverage['monitor.js'][277]++;
  self.poll_cpu(target, (function (err, stats_start) {
  _$jscoverage['monitor.js'][278]++;
  setTimeout((function () {
  _$jscoverage['monitor.js'][279]++;
  self.poll_cpu(target, (function (err, stats_end) {
  _$jscoverage['monitor.js'][280]++;
  var idle_delta = parseFloat(stats_end.idle - stats_start.idle);
  _$jscoverage['monitor.js'][281]++;
  var total_delta = parseFloat(stats_end.total - stats_start.total);
  _$jscoverage['monitor.js'][282]++;
  var cpuUsage = ((total_delta - idle_delta) / total_delta) * 100;
  _$jscoverage['monitor.js'][284]++;
  callback(null, cpuUsage.toFixed(2));
}));
}), 1000);
}));
});
_$jscoverage['monitor.js'][321]++;
module.exports = new Monitor();
_$jscoverage['monitor.js'].source = ["/**"," * Module dependencies."," */","var child_process = require(\"child_process\");","var exec = child_process.exec","var fs = require(\"fs\");","var Utils = require(\"./utils\");","","/**"," * Monitor constructor"," *"," * @api public"," */","function Monitor(options) {","  // TODO: enable cross platform support via separate os-specific files","  this.options = Utils.merge({}, this._options, options || {});","  ","  // console.log(process.platform);","  if (process.platform !== \"linux\") {","    throw process.platform + \" is currently not supported by Monitor\";","  }","  ","  this.MaxRAM = this.getMaxRAM();","  ","  this.public_methods = [\"uptime\", \"memory\", \"cpu\", \"pcpu\", \"response_time\"];","  // if (this.get_geocity() !== null){","  //   this.public_methods.append(\"geolocate\");","  // }","  ","  return this;","}","","/**"," * Default options for Monitor"," */","Monitor.prototype._options = {","  outbound: {","    transport: \"http\",","    host: null,","    interval: 30000","  },","  inbound: {","    route: \"/_monitor/\",","  },","  geodat: null","}","","/**"," * Register process with monitoring collector for inbound polling"," */","Monitor.prototype.register = function() {","  // TODO:","  ","  process.on(\"exit\", this.deregister);","}","","/**"," * Unregister process with monitoring collector for inbound polling"," */","Monitor.prototype.deregister = function(){ ","  // TODO:","}","","/**"," * Getter for geo dat file"," */","Monitor.prototype.get_geocity = function(){","  if (typeof this.options.geodat !== \"undefined\" &amp;&amp; this.options.geodata !== null) {","    if (path.existsSync(this.options.geodat)){","      ","      // TODO: move this into a loader","      try {","        var geoip = require(\"geoip\"); // requires ","        var City = geoip.City;","        var city = new City(this.options.geodat);","      } catch (err) {","        return null;","      }","      ","      return this.options.geodat;","    }","  }","  ","  return null;","}","","/**"," * Middleware (early in stack) required for other Monitor middleware to work"," */","Monitor.prototype.onPreRoute = function(req, res, next) {","  req._startTime = new Date; // Used to determine request response time ","  // TODO: warm up cpu poll function?","  ","  next();","}","","/**"," * Middleware to make req[:fn] available to request handlers"," */","Monitor.prototype.onPreHandler = function() {  ","  var wrapped = function(req, res, next) {","    if (!req._startTime) throw \"Monitor.onPreHandler middleware requires Monitor.onPreRoute\"","    ","    // TODO: evaluate this approach vs just exposing Monitor directly","    for(var i in this.public_methods) {","      req[this.public_methods[i]] = this[this.public_methods[i]];","    }","    ","    next();","  }","  ","  return wrapped;","}","","/**"," * Middleware to include /_monitor/:fn routes"," */","Monitor.prototype.onPostHandler = function() {","  // \"global middleware variables\"","  // var interval = this.options.outbound.interval;","  ","  var wrapped = function(req, res, next) {","    if (!req._startTime) throw \"Monitor.onPostHandler middleware requires Monitor.onPreRoute\"","    ","    try {","      var url = decodeURIComponent(req.url);","    } catch (e) {","      throw e; // TODO: properly respond to error","    }","    ","    // TODO: if route matches this.options.inbound.route + \":fn\", return response","    ","    next();","  }","  ","  // this.register();","  ","  return wrapped;","}","","Monitor.prototype.calcMaxRAM = function() {","  var meminfo = '/proc/meminfo';","  var pattern = /MemTotal:[\\s]+(\\d+)\\s+kB/;","  var meminfoContents = fs.readFileSync(meminfo);","  var match = pattern.exec(meminfoContents.toString());","  ","  if (match !== null) {","    var totalRAM = parseInt(match[1]) * 1000; // KB to Bytes","    if (!isNaN(totalRAM)) {","      return totalRAM;","    }","  }","  ","  throw \"Unable to determined Maximum Available RAM\";","}","","Monitor.prototype.getMaxRAM = function() {","  if (typeof this.MaxRAM === \"undefined\" || this.MaxRAM === null) {","    this.MaxRAM = this.calcMaxRAM();","  }","  return this.MaxRAM;","}","","/**"," * Returns process uptime in seconds"," *"," * @api public"," * @param digits number of decimal places to keep, default 2"," */ ","Monitor.prototype.uptime = function(digits) {","  digits = digits || 2","  return process.uptime().toFixed(digits);","}","","/**"," * Returns an object with total &amp; memory used by process"," */","Monitor.prototype.memory = function() {","  var snapshot = process.memoryUsage();","  var usage = {","    total: this.getMaxRAM(),","    used: snapshot.rss + snapshot.heapTotal","  }","  ","  // console.log((usage.used / usage.total) * 100);","  return usage;","}","","/**"," * Return request response time"," *"," * @api public"," * @param req Express request object"," */","Monitor.prototype.responseTime =","Monitor.prototype.response_time = function(req) {","  if (!req._startTime) return null;","  ","  return new Date - req._startTime;","}","","/**"," * Return percentage of CPU core used by THIS process"," *"," * @api public"," * @param callback function to process result"," */","Monitor.prototype.pcpu = function(callback) {","  exec('ps -eo pcpu,pid | grep ' + process.pid, function (error, stdout, stderr) {","    if (error) return callback(error);","    var cpuUsage = Number(stdout.split(\" \").shift()).toFixed(2);","    callback(null, cpuUsage)","  })","}","","/**"," * Grab CPU idle, total usage information for cores from /proc/stat"," *"," * @api private "," * @param callback function to process the asynchronous result"," */","Monitor.prototype.poll_cpu = function(target, callback) {","  var statfile = '/proc/stat';","  try {","    fs.readFile(statfile, function(err, contents) {","      if (err) throw err;","      ","      // TODO: FUTURE: optimization for later, if target known, customize regexp for that","      var pattern = /cpu[\\d]?[\\s]+(.*)/g;","      var file_contents = contents.toString();","      ","      var result;","      var cpulines = {};","      while ((result = pattern.exec(file_contents)) != null) {","        var source = result[0].split(/\\s+/);","        var cpu = source.shift(); // remove 'cpu(\\d?)' from string","        var line = source.map(function(d){ return +d; }); // convert all to Number","        line = line.slice(0,4); // strip non-relevant numbers","        cpulines[cpu] = line;","        ","        if (target === cpu){","          break; // short circuit if found","        }","      }","      ","      if (!cpulines.hasOwnProperty(target)){","        return callback(\"No such target found for Monitor.poll_cpu (\" + target + \" does not exist)\");","      }","      ","      var cpuline = cpulines[target];","      var cpustats = {","        idle: cpuline[3],","        total: cpuline.reduce(function(a, b){ return a + b; })","      }","      ","      return callback(null, cpustats);","    })","  } catch (err) {","    return callback(err);","  }","}","","/**"," * Return total cpu usage percentage from across all cores"," * "," * @api public"," * @param callback function to handle response"," */","Monitor.prototype.cpu = function(target, callback) {","  // TODO: OS-support: only tested on RHEL, doesn't work on OSX","  if (typeof target === \"function\"){","    callback = target;","    target = 'cpu';","  }","  ","  var self = this;","  self.poll_cpu(target, function(err, stats_start) {","    setTimeout((function(){","      self.poll_cpu(target, function(err, stats_end) {","        var idle_delta = parseFloat(stats_end.idle - stats_start.idle);","        var total_delta = parseFloat(stats_end.total - stats_start.total);","        var cpuUsage = ((total_delta - idle_delta) / (total_delta)) * 100;","        ","        callback(null, cpuUsage.toFixed(2));","      })","    }), 1000)","  })","}","","// TODO: move this out to an optional, separate module","/**"," * Geolocate an incoming request"," *"," * @api public"," * @param req Express request object"," * @param callback function to process the result"," */","// Monitor.prototype.geolocate = function(req, callback) {","//   var ip_address = req.socket &amp;&amp; (req.socket.remoteAddress || (req.socket.socket &amp;&amp; req.socket.socket.remoteAddress));","//   var geodat = this.get_geocity();","//   if (!geodat) {","//     return callback(\"Must configure a geodat file to use Monitor.geolocate()\");","//   }","  ","//   try {","//     var geoip = require(\"geoip\"); // requires libgeoip c module","//     var City = geoip.City;","//     var city = new City(geodat);","//   } catch (err) {","//     return callback(err);","//   }","  ","//   city.lookup(ip_address, function(err, data) {","//     if (err) return callback(err);","    ","//     callback(null, data);","//   });","// }","","// Module exports","module.exports = new Monitor();"];
